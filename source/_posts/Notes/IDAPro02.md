---
title: 函数调用约定
date: 2023-07-29 14:59:58
categories: 笔记 #
tags: [IDA]
---
阅读《IDA Pro权威指南》调用约定部分。以下是一些阅读笔记：
先push再call，参数先入栈，接着才是返回地址

## 1.)C调用约定。

x86结构的c编译器默认调用约定_cdecl：调用方在栈里放和清除参数，非常适合参数数量可变的调用情况。
gnu编译器：预先分配存储空间，在参数刚到栈上时，不需要修改程序栈指针；调用结束后，自然也就不需要调整栈指针。
在调用函数时，栈指针指向最左边的参数，毕竟从右向左压栈。

## 2.)stdcall调用约定

微软对所有由dll文件输出的参数固定的函数使用的调用约定，在函数结束执行时，由被调用的函数负责删除栈上的函数参数，仅适用于函数参数固定的情形。
printf不可能是stdcall调用。
ret相当于pop eip
ret 12相当于pop retAddress        Add esp,12,
因此，从stdcall类的函数返回后，不需要调整栈，因为被调用方已经调整过了。



## 3.)fastcall调用约定，

从左往右数的前两个参数分别放到cpu寄存器ecx，edx里，剩余参数按照stdcall压栈。

## 4.)C++调用约定，

this对象的地址必须由调用方作为参数提供。
VC++的thiscall调用约定，将this传递给ecx寄存器，其他参数适用于stdcall；
gnu的g++将this看成任何非静态成员函数的第一个隐含参数，其他方面与cdecl调用一致，由调用方负责删除栈里的参数。

## 5.)代码优化、汇编和系统调用的约定很特殊。

```
利用汇编混淆时，可以随意传参。
设置只有内部函数才了解的调用约定：
mvc++的/GL和g++的regparm关键字。
push ebp
mov ebp,esp
sub esp,64
此时，ebp将返回地址、参数与局部变量分割成两部分。
一些惯例，栈指针，正偏移量用于访问参数，负偏移量用于访问局部变量。
基于ebp的栈访问，从函数调用离开时，
mov ebp,esp       简化为 leave
pop ebp                  ret
ret        
```

